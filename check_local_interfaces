#!/usr/bin/perl

# Copyright (c) 2014, Evgeni Golov
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice, this
#   list of conditions and the following disclaimer in the documentation and/or
#   other materials provided with the distribution.
#
# * Neither the name of the {organization} nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use strict;
use warnings;
use Nagios::Plugin;

my $proc = '/proc/net/dev';

my $np = Nagios::Plugin->new(
    usage => "Usage: %s [ -i|--interface=<interface>] "
      . "[ -w|--warning=<port> ] "
      . "[ -c|--critical=<port> ] ",
    shortname => 'Check local interface stats',
    url       => 'https://github.com/evgeni/check_local_interfaces',
    version   => '0.1',
    license   => 'This plugin is free software, and comes with ABSOLUTELY
NO WARRANTY. It may be used, redistributed and/or modified under
the terms of the BSD 3-clause license.',
);

$np->add_arg(
    spec => 'interface|i=s@',
    help =>
'Interface to be monitored, can be given multiple times. Defaults to ALL interfaces.',
);

$np->add_arg(
    spec    => 'sleep|s=i',
    help    => 'Sleep between taking samples (default: %s)',
    default => 5,
);

$np->add_arg(
    spec => 'warnrxbytes|w=i',
    help =>
'WARNING if more than X bytes/s were received during sample period (default: %s)',
    default => 0,
);

$np->add_arg(
    spec => 'critrxbytes|c=i',
    help =>
'CRITICAL if more than X bytes/s were received during sample period (default: %s)',
    default => 0,
);

$np->add_arg(
    spec => 'warntxbytes|W=i',
    help =>
'WARNING if more than X bytes/s were sent during sample period (default: %s)',
    default => 0,
);

$np->add_arg(
    spec => 'crittxbytes|C=i',
    help =>
'CRITICAL if more than X bytes/s were sent during sample period (default: %s)',
    default => 0,
);

$np->add_arg(
    spec => 'warnerrs|e=i',
    help =>
'WARNING if more than X errors/s were seen during sample period (default: %s)',
    default => 0,
);

$np->add_arg(
    spec => 'criterrs|E=i',
    help =>
'CRITICAL if more than X errors/s were seen during sample period (default: %s)',
    default => 0,
);

$np->add_arg(
    spec => 'units|u=s',
    help =>
'Output speeds in units/second (default: %s, needs Number::Format for everything else)',
    default => 'bytes',
);

$np->getopts;

sub get_interface_stats {

    my %interfaces;

    open( my $stats, "<", $proc )
      or $np->nagios_exit( 'UNKNOWN', "Could not open $proc" );

    while (<$stats>) {
        chomp;
        next unless /^\s+([\w\d]+): (.*)/;
        my $interface = $1;
        my (
            $rxbytes, $rxpackets, $rxerrs,       $rxdrop,
            $rxfifo,  $rxframe,   $rxcompressed, $rxmulticast,
            $txbytes, $txpackets, $txerrs,       $txdrop,
            $txfifo,  $txcolls,   $txcarrier,    $txcompressed
        ) = split( ' ', $2 );
        $interfaces{$interface} = {
            rxbytes      => $rxbytes,
            rxerrs       => $rxerrs,
            rxdrop       => $rxdrop,
            rxfifo       => $rxfifo,
            rxframe      => $rxframe,
            rxcompressed => $rxcompressed,
            rxmulticast  => $rxmulticast,
            txbytes      => $txbytes,
            txpackets    => $txpackets,
            txerrs       => $txerrs,
            txdrop       => $txdrop,
            txfifo       => $txfifo,
            txcolls      => $txcolls,
            txcarrier    => $txcarrier,
            txcompressed => $txcompressed
        };
    }

    return %interfaces;
}

sub convert_units {
    my ( $bytes, $unit ) = @_;
    require Number::Format;
    return Number::Format::unformat_number(
        Number::Format::format_bytes( $bytes, unit => $unit ) );
}

my %old_stats = get_interface_stats();
sleep( $np->opts->sleep );
my %new_stats = get_interface_stats();

my $check_interfaces;
if ( $np->opts->interface ) {
    $check_interfaces = $np->opts->interface;
}
else {
    $check_interfaces = [ keys %new_stats ];
}

foreach my $interface (@$check_interfaces) {
    my $rxbytes =
      ( $new_stats{$interface}{rxbytes} - $old_stats{$interface}{rxbytes} ) /
      $np->opts->sleep;
    my $txbytes =
      ( $new_stats{$interface}{txbytes} - $old_stats{$interface}{txbytes} ) /
      $np->opts->sleep;
    my $rxerrs =
      ( $new_stats{$interface}{rxerrs} - $old_stats{$interface}{rxerrs} ) /
      $np->opts->sleep;
    my $txerrs =
      ( $new_stats{$interface}{txerrs} - $old_stats{$interface}{txerrs} ) /
      $np->opts->sleep;

    if ( $np->opts->units ne 'bytes' ) {
        $rxbytes = convert_units( $rxbytes, $np->opts->units );
        $txbytes = convert_units( $txbytes, $np->opts->units );
    }

    if ( $np->opts->critrxbytes > 0 && $rxbytes > $np->opts->critrxbytes ) {
        $np->add_message( CRITICAL,
            "$interface RX: $rxbytes " . $np->opts->units . "/s\n" );
    }
    elsif ( $np->opts->warnrxbytes > 0 && $rxbytes > $np->opts->warnrxbytes ) {
        $np->add_message( WARNING,
            "$interface RX: $rxbytes " . $np->opts->units . "/s\n" );
    }
    else {
        $np->add_message( OK,
            "$interface RX: $rxbytes " . $np->opts->units . "/s\n" );
    }

    if ( $np->opts->crittxbytes > 0 && $txbytes > $np->opts->crittxbytes ) {
        $np->add_message( CRITICAL,
            "$interface TX: $txbytes " . $np->opts->units . "/s\n" );
    }
    elsif ( $np->opts->warntxbytes > 0 && $txbytes > $np->opts->warntxbytes ) {
        $np->add_message( WARNING,
            "$interface TX: $txbytes " . $np->opts->units . "/s\n" );
    }
    else {
        $np->add_message( OK,
            "$interface TX: $txbytes " . $np->opts->units . "/s\n" );
    }

    if ( $np->opts->criterrs > 0 && $rxerrs > $np->opts->criterrs ) {
        $np->add_message( CRITICAL, "$interface RX-ERRS: $rxerrs errs/s\n" );
    }
    elsif ( $np->opts->warnerrs > 0 && $rxerrs > $np->opts->warnerrs ) {
        $np->add_message( WARNING, "$interface RX-ERRS: $rxerrs errs/s\n" );
    }
    else {
        $np->add_message( OK, "$interface RX-ERRS: $rxerrs errs/s\n" );
    }

    if ( $np->opts->criterrs > 0 && $txerrs > $np->opts->criterrs ) {
        $np->add_message( CRITICAL, "$interface TX-ERRS: $txerrs errs/s\n" );
    }
    elsif ( $np->opts->warnerrs > 0 && $txerrs > $np->opts->warnerrs ) {
        $np->add_message( WARNING, "$interface TX-ERRS: $txerrs errs/s\n" );
    }
    else {
        $np->add_message( OK, "$interface TX-ERRS: $txerrs errs/s\n" );
    }

    $np->add_perfdata(
        label    => $interface . '-rx',
        value    => $rxbytes,
        uom      => $np->opts->units . "/s",
        warning  => $np->opts->warnrxbytes,
        critical => $np->opts->critrxbytes,
    );

    $np->add_perfdata(
        label    => $interface . '-tx',
        value    => $txbytes,
        uom      => $np->opts->units . "/s",
        warning  => $np->opts->warntxbytes,
        critical => $np->opts->crittxbytes,
    );

    $np->add_perfdata(
        label    => $interface . '-rxerrs',
        value    => $rxerrs,
        uom      => "errs/s",
        warning  => $np->opts->warnerrs,
        critical => $np->opts->criterrs,
    );

    $np->add_perfdata(
        label    => $interface . '-txerrs',
        value    => $txerrs,
        uom      => "errs/s",
        warning  => $np->opts->warnerrs,
        critical => $np->opts->criterrs,
    );
}

my $code;
my $message;
( $code, $message ) = $np->check_messages;

$np->nagios_exit( $code, $message );
